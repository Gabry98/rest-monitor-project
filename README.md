# rest-monitor
This Java application intends to simulate the functionalities of a backend monitor developed for the purpose to call exposed endpoints to execute some APIs.
The project has been developed with the framework **Quarkus** (for more info: https://quarkus.io/), and it uses **Apache Maven** for the build automation.
The following are requirements for the correct execution of the application:

1. **Docker**: used for containerization purposes and for define the image of the whole application
2. **SW Interface for Docker containers**: required while you're using the application. An example can be **Docker Desktop** (for non-commercial purposes), otherwise you can use a software like **Portainer**. In any case, the software that you will use should be actived during maven builds (mandatory to define the docker image of the monitor, with the specific name defined inside the **application.properties** with the help of quarkus properties) and while you are executing the whole application.
3. **Docker Compose**: required for the execution of the whole application with its containers. There'll be 3 containers: the one for **postgres DB** (the properties to connect to it are already defined inside the **application.properties** file of the rest-monitor), the one for **pgAdmin**, which is a free interface done for the management of postgres databases, and in the end the container for **rest-monitor** itself. Note that the monitor and the postgresDB have two volumes: for the monitor there will be a directory mounted for a specific API available inside of it, which gives the possibility to import some users data inside the db (the api is defined whit the name **create-user-with-file**, and should have as body a Text with the directory of the file. Since there is a file already available for try the api, **file_for_creation.csv**, the standard directory must be **/file_directory/file_for_creation.csv**). The container for the DB, instead, is used for the script of initialization of the only entity present on this project, which in the java code has a representation with the class **UserEntity**.
4. **Postman**: as an instrument for make a call directly to the exposed endpoints. The users will have id, name, surname, email and address: the body that you can use for operations like the creation of new data, will be made by the whole attributes described except for the id: that one will be generated with the help of the UUID library inside java (for security reason, when a new user will be generated, the id defined will be checked in any case to see if it is already present inside the DB).

